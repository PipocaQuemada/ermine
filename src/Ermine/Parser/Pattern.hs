{-# LANGUAGE TupleSections #-}
{-# LANGUAGE OverloadedStrings #-}
--------------------------------------------------------------------
-- |
-- Copyright :  (c) Edward Kmett and Dan Doel 2013
-- License   :  BSD3
-- Maintainer:  Edward Kmett <ekmett@gmail.com>
-- Stability :  experimental
-- Portability: non-portable
--
-- This module provides the parser for terms
--------------------------------------------------------------------
module Ermine.Parser.Pattern
  ( validate
  , pattern
  , pattern0
  , PP
  ) where

import Control.Applicative
import Control.Lens hiding (op)
import Data.Foldable as Foldable
import Data.Text (Text)
import Data.Void
import qualified Data.Set as Set
import Ermine.Builtin.Pattern
import Ermine.Parser.Literal
import Ermine.Parser.Style
import Ermine.Parser.Type
import Ermine.Syntax
import Ermine.Syntax.Global
import Ermine.Syntax.ModuleName
import Text.Parser.Combinators
import Text.Parser.Token

-- | Check a 'Binder' for linearity.
--
-- Each variable name must be used at most once in the pattern.
validate :: (Functor m, Monad m, Ord v) => Binder v a -> (v -> m Void) -> m ()
validate b e =
  () <$ foldlM (\s n -> if n `Set.member` s then vacuous $ e n else return $ Set.insert n s)
               Set.empty
               (vars b)

-- | The simple pattern type generated by pattern parsing.
type PP = P Ann Text

varP :: (Monad m, TokenParsing m) => m PP
varP = termIdentifier <&> sigp ?? anyType

-- | Parse a single pattern part (e.g. an argument to a lambda)
pattern0 :: (Monad m, TokenParsing m) => m PP
pattern0 = varP
   <|> _p <$ symbol "_"
   <|> litp <$> literal
   <|> parens (tup' <$> patterns)

tup' :: [PP] -> PP
tup' [x] = x
tup' xs = tup xs

sigP :: (Monad m, TokenParsing m) => m PP
sigP = sigp <$> try (termIdentifier <* colon) <*> annotation

-- TODO: remove this when constructor patterns really work.
eP :: (Monad m, TokenParsing m) => m PP
eP = conp nm <$ symbol "E" <*> many pattern1
 where
 nm = glob Idfix (mkModuleName "ermine" "Ermine") "E"

pattern1 :: (Monad m, TokenParsing m) => m PP
pattern1 = asp <$> try (termIdentifier <* symbol "@") <*> pattern1 <|> pattern0

pattern2 :: (Monad m, TokenParsing m) => m PP
pattern2 = eP <|> sigP <|> pattern0

patterns :: (Monad m, TokenParsing m) => m [PP]
patterns = commaSep pattern2

-- | Parse a single pattern (e.g. a case statement alt pattern)
pattern :: (Monad m, TokenParsing m) => m PP
pattern = pattern1
